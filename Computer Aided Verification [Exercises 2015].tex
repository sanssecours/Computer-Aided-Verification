%!TEX TS-program = xelatex

% -- Document Class -----------------------------------------------------------

\documentclass[a4paper, 11pt]{article}

% -- Packages -----------------------------------------------------------------

% Language
\usepackage{polyglossia}
    \setmainlanguage{english}
    \setotherlanguage{german}
% Context sensitive quotation
\usepackage{csquotes}
% Customize enumerations
\usepackage{enumitem}
% Extend options for positioning floats
\usepackage{float}
% Support highlighting of certain parts of the text
\usepackage{framed}
% Support spaces in filenames
\usepackage{grffile}
% Tools for mathematical typesetting
\usepackage{mathtools}
% Headers & Footers
\usepackage[automark, nouppercase]{scrpage2}
% Emphasize text
\usepackage{soul}
% To change the format of titles
\usepackage{titlesec}
% Support for unicode math fonts
\usepackage{unicode-math}
% Extended color support
\usepackage[x11names]{xcolor}
% Extras for XƎTEX
\usepackage{xltxtra}
% Hyperlinks and pdf properties
\usepackage{hyperref}

% -- Color Definitions --------------------------------------------------------

% Background color for syntax highlighting
\definecolor{bgcolor}{rgb}      {1,     1,      1}

% Custom color definitions
\definecolor{aqua}{rgb}         {0,     0.56,   1}
\definecolor{bluegray}{rgb}     {0.22,  0.46,   0.84}
\definecolor{grape}{rgb}        {0.56,  0,      1}
\definecolor{lightgray}{rgb}	{0.94,	0.94,	0.94}
\definecolor{orchid}{rgb}       {0.41,  0.13,   0.55}
\definecolor{orange}{rgb}       {1,     0.54,   0}
\definecolor{silver}{rgb}       {0.57,  0.57,   0.57}
\definecolor{turquoise}{rgb}    {0,     0.86,   0.84}

% -- Macros -------------------------------------------------------------------

\newcommand{\Title}{Exercises}
\newcommand{\TitleDescription}{Computer Aided Verification}
\newcommand{\Version}{1}
\newcommand{\Subject}
    {Solutions for the exercises of the course Computer Aided Verification}
\newcommand{\KeyWords}{BDD, Kripke structure}
\newcommand{\LeftFooter}{\Title~—~\TitleDescription}

\newcommand{\AuthorOne}{René Schwaiger}
\newcommand{\MailOne}{\href{mailto:sanssecours@f-m.fm}{sanssecours@f-m.fm}}

% Syntax highlighting definitions
% Text
\newcommand{\hlstd}[1]{\textcolor{black}{#1}}
% Numbers
\newcommand{\hlnum}[1]{\textcolor{DarkOrchid4}{#1}}
\newcommand{\hlesc}[1]{\textcolor[rgb]{1,0,1}{#1}}
% Strings
\newcommand{\hlstr}[1]{\textcolor{SeaGreen3}{#1}}
\newcommand{\hlpps}[1]{\textcolor[rgb]{0.51,0.51,0}{#1}}
% Comments
\newcommand{\hlslc}[1]{\textcolor{aqua}{#1}}
\newcommand{\hlcom}[1]{\textcolor{aqua}{#1}}
\newcommand{\hlppc}[1]{\textcolor[rgb]{0,0.51,0}{#1}}
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\hllin}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
% Keywords
\newcommand{\hlkwa}[1]{\textcolor{DodgerBlue3}{#1}}
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0,0.34,0.68}{#1}}
\newcommand{\hlkwc}[1]{\textcolor{DarkOrchid4}{#1}}
% Functions
\newcommand{\hlkwd}[1]{\textcolor{orange}{#1}}

\newcommand{\codeinput}[1]
{
    \vskip 0.3 cm
    {\color{lightgray}\hrule}\vskip 0.3 cm
    {\fontsize{9pt}{11pt}\input{Code/#1}}
    \vskip 0.3 cm{\color{lightgray}\hrule}
    \vskip 0.3 cm
}

\newcommand{\code}[1]
{
    \hl{\texttt{#1}}
}

% -- Document Properties ------------------------------------------------------

% Background color for highlighted text
\sethlcolor{lightgray}

% No indentation after paragraphs
\setlength\parindent{0cm}

% Hyperref properties
\hypersetup
{
    pdftitle    = {\Title},
    pdfsubject  = {\Subject},
    pdfauthor   = {\AuthorOne},
    pdfkeywords = {\KeyWords},
    colorlinks  = true,
    linkcolor   = black,
    anchorcolor = black,
    citecolor   = silver,
    urlcolor    = orange
}

% -- Fonts --------------------------------------------------------------------

% Use same size for numbers and other text
\defaultfontfeatures{Numbers=Lining}

% Set fonts for document
\setmainfont[Mapping=tex-text]{Avenir Next}
\setsansfont[Mapping=tex-text]{Ubuntu}
\setmonofont[Scale=MatchLowercase]{Menlo}
\setmathfont{Asana-Math.otf}
\setmathfont[range=\mathtt, Scale=MatchLowercase]{Menlo}

% Define font styles
\newfontfamily\Zapfino{Zapfino}

% -- Header And Footers -------------------------------------------------------

% Use normal font instead of italic font for head
\renewcommand{\headfont}{\normalfont}

% Set headers and footers
\ihead{\headmark}
\ohead{}
\ifoot{\LeftFooter}
\ofoot{\thepage}

% Set height of head
\setlength{\headheight}{1.8\baselineskip}

% Set thickness of separation line in header, footer
\setheadsepline{0.5pt}
\setfootsepline{0.5pt}

% -- Titlepage ----------------------------------------------------------------

\pagestyle{empty}
\begin{document}

\begin{titlepage}
    \begin{center}
        % Title and title-description
        {\Huge\Zapfino\Title}
        \vskip 0.5cm
        {\color{aqua}\hrule}
        \vskip 0.5cm
        {\Large\textit\TitleDescription}
        \vskip 14cm
    \end{center}

    % Date and version number
    \begin{leftbar}
        \begin{tabular}{ll}
            \textbf{Author}  & \AuthorOne\\
            \textbf{Mail}    & \MailOne\\
            \textbf{Version} & \Version\\
            \textbf{Date}    & \today
        \end{tabular}
    \end{leftbar}

\end{titlepage}


% -- Table of Contents --------------------------------------------------------

% Set section format for table of contents
\titleformat{\section}{\sffamily\bfseries}{}{0pt}{}[{\color{aqua}\hrule}]

% Set separation of dots between name of section and page number to such a high
% value that there will be no points in the table of contents
\makeatletter \renewcommand{\@dotsep}{10000} \makeatother
% Use blank header and footer
\pagestyle{empty}
% Start on new page
\newpage
% The table of contents starts at the second page
\setcounter{page}{2}
% Set table of contents
\tableofcontents

% -- Section & Paragraph Style ------------------------------------------------

% Set format for section
\titleformat{\section}
    {\large\sffamily\bfseries}  % Large, bold, sans serif font for section
    {}                          % No format applied to whole title
    {0pt}                       % No separation between label and title
    {\thesection~·~}            % Start with section number
    [{\color{aqua}\hrule}]      % Underline with blue ruler

% Set format for other sections and paragraphs
% Color = orchid, Font = bold, sans serif
\titleformat*{\subsection}{\color{orchid}\sffamily\bfseries}
\titleformat*{\subsubsection}{\color{orchid}\sffamily\bfseries}
\titleformat*{\paragraph}{\color{orchid}\sffamily\bfseries}
\titleformat*{\subparagraph}{\color{orchid}\sffamily\bfseries}

% -- Page Style ---------------------------------------------------------------

% Start with text on a new page
\newpage
% Display headers and footers
\pagestyle{scrheadings}

% -- Text ---------------------------------------------------------------------

\section{Binary Decision Diagrams}

\subsection{Exercise 1}

Give a linear time algorithm for BDD isomorphism as defined on page 9.

\subsubsection{Solution}

The following code assumes the existence of the functions:

\begin{description}[style=multiline, leftmargin=3cm]
    \item[\texttt{is\_terminal(v)}] Returns \texttt{True} if \texttt{v} is a terminal vertex and \texttt{False} otherwise
\end{description}

\paragraph{Nonterminal Vertices}

\begin{description}[style=multiline, leftmargin=3cm]
    \item [\texttt{var(v)}] Returns the variable of a BDD vertex.
    \item [\texttt{low(v)}] Returns the “low” successor of the BDD vertex (v is set to 0)
    \item [\texttt{high(v)}] Returns the “high” successor of the BDD vertex (v is set to 1)
\end{description}

\paragraph{Terminal Vertices}

\begin{description}[style=multiline, leftmargin=3cm]
    \item[\texttt{high(v)}] Returns the value of v (Either 0 or 1)
\end{description}

\codeinput{isomorphic}

\newpage
\subsection{Exercise 2}

Show that the three operations on page 12 commute.

\subsubsection{Solution}

We have the following operations:

\begin{description}[style=multiline, leftmargin=3.6cm]
    \item[Remove duplicate terminals] Eliminate all but one terminal vertex with a given label and redirect all arcs to the eliminated vertices to the remaining one.
    \item[Remove duplicate nonterminals] If nonterminals $u$ and $v$ have $high(u)=high(v)$, $low(u)=low(v)$ and $high(u)=high(v)$, then eliminate one of the two vertices and redirect all incoming arcs to the other vertex.
    \item[Remove redundant test] If nonterminal vertex $v$ has $low(v)=high(v)$, then eliminate $v$ and redirect all incoming arcs to $low(v)$.
\end{description}

We now use the following abbreviations for these operations:

\begin{description}[style=multiline]
    \item[dt()] Remove duplicate terminals
    \item[dn()] Remove duplicate nonterminals
    \item[rt()] Remove redundant test
\end{description}

To show that these operations are commutative — the order of application does not matter – we need to show the following:

\begin{enumerate}
    \item $dt(dn(bdd)) = dn(dt(bdd))$
    \item $dt(rt(bdd)) = rt(dt(bdd))$
    \item $dn(rt(bdd)) = rt(dn(bdd))$
\end{enumerate}

$bdd$ describes an arbitrary binary decision diagram.

\paragraph{dt(dn(bdd)) = dn(dt(bdd))}

The only place where the order of operations could matter is on the bottom of the graph, where nonterminal nodes connect to terminal nodes. In the other case the operations work on different parts of the tree.\\

If we first remove duplicate nonterminal nodes, then theoretically we could remove one of the two terminal nodes, that we used if we first removed the duplicate terminals. Figure~\ref{fig:Figures_BDD_Removed_Terminals_And_Nonterminals} shows an example of this behaviour. This does however not change the semantics, since every terminal vertex $v$ with $value(v)=0$ is isomorphic to a vertex $u$ with $value(u)=0$. The same of course is true for terminal vertices that have a value of 1.

\begin{figure}[h]
  \centering
    \includegraphics[width=.9\textwidth]{Figures/BDD Removed Terminals And Nonterminals.pdf}
  \caption{Removal of terminal and nonterminal nodes in a BDD}
  \label{fig:Figures_BDD_Removed_Terminals_And_Nonterminals}
\end{figure}

\paragraph{dt(rt(bdd)) = rt(dt(bdd))}

This case is similar to the one before. The only place where the order of the operations matter is at the bottom of the tree.

\begin{figure}[h]
  \centering
    \includegraphics[width=.75\textwidth]{Figures/BDD Removed Terminals And Redundant Tests.pdf}
  \caption{Removal of redundant test and terminal nodes in a BBD}
  \label{fig:Figures_BDD_Removed_Terminals_And_Redundant_Tests}
\end{figure}

Since the removal of redundant test does not change the nodes at the bottom of the tree, all the nodes at the bottom stay. This also means that the reduction works on the same terminal nodes, regardless if we reduce the terminal nodes at the start or after we remove the redundant tests. This in turn means that the order of application does not matter. For an example of this behaviour take a look at Figure~\ref{fig:Figures_BDD_Removed_Terminals_And_Redundant_Tests}.

\paragraph{dn(rt(bdd)) = rt(dn(bdd))}

There is one possibility, where removing redundant tests and redundant nonterminals work on the same part of a BDD. Figure~\ref{fig:Figures_BDD_Removed_Nonterminals_And_Redundant_Tests} shows this possibility. The top part of the graph displays the result if redundant test are removed first. The bottom part shows the result if the redundant nonterminals are removed first. Both times we get the same result. This shows that even if both operations work on the same part of the graph, the application order does not matter.

\begin{figure}[h]
  \centering
    \includegraphics[width=.6\textwidth]{Figures/BDD Removed Nonterminals And Redundant Tests.pdf}
  \caption{Removal of redundant nonterminals and tests}
  \label{fig:Figures_BDD_Removed_Nonterminals_And_Redundant_Tests}
\end{figure}

\newpage
\subsection{Exercise 3}

Describe a size-efficient BDD for the relation “a<b” for n-bit integer numbers.

\subsubsection{Solution}

We assume that:

\begin{itemize}
    \item $a$ has the form $a_na_{n-1}…a_0$, where $a_n$ ist the most significant bit.
    \item $b$ is encoded in the same way as $a$.
    \item Both $a$ and $b$ are positive numbers.
\end{itemize}

Figure~\ref{fig:Figures_OBDD_Smaller} shows the BDD that encodes the boolean operation “a<b”.

\begin{figure}[h]
  \centering
    \includegraphics[width=.54\textwidth]{Figures/OBDD Smaller.pdf}
  \caption{An OBBD for the operation “a<b”}
  \label{fig:Figures_OBDD_Smaller}
\end{figure}

\subsection{Exercise 4}

Describe an algorithm which transforms a boolean formula into an equivalent binary decision diagram.

\subsubsection{Solution}

First we need to tokenize and parse the formula. We can use an user friendly parsing library like \href{http://www.dabeaz.com/ply/}{PLY} to do this job. Our basic grammar for formulas would look something like this:

\codeinput{boolean_formula}

The parsing library calls different functions according to the tokens it encounters:

\begin{itemize}
    \item \code{rule\_variable(tokens)}
    \item \code{rule\_constant(tokens)}
    \item \code{rule\_expression(tokens)}
    \item \code{rule\_formula(tokens)}
\end{itemize}

We assume that the functions get a list of the tokens or return values for the matched rule as argument. For example: The (partial) input: $a ∨ 0$ would mean that:

\begin{flushleft}
\begin{itemize}
    \item \code{rule\_variable(tokens)} gets called with \code{tokens = ['a']},

    \item then \code{rule\_constant(tokens)} gets called with \code{tokens = [0]}.

    \item After that, \code{rule\_expression(tokens)} gets called with \code{tokens = [result\_constant, '∨', result\_variable]}.\\[0.5cm]

    \code{result\_constant} and \code{result\_variable} are the values returned by the functions \code{rule\_constant()} and \code{rule\_variable()}.
\end{itemize}
\end{flushleft}

We already defined the parsing process. Now we specify the algorithms used for the parsing functions.

\paragraph{rule\_variable()}

In this rule we create the BDD for the given variable. Figure~\ref{fig:BDD_Variable} shows this simple BDD for the variable $x$.

\begin{figure}[h]
  \centering
    \includegraphics[width=.2\textwidth]{Figures/BDD Variable.pdf}
  \caption{BDD for a single variable $x$}
  \label{fig:BDD_Variable}
\end{figure}

The following listing shows the pseudocode for the function:

\codeinput{rule_variable}

\paragraph{rule\_constant()}

Depending on the given constant we either create the trivial BDD that represents “true” consisting only of the terminal node “1”, or the BDD that only consists of the terminal node “0” representing “false”.

\codeinput{rule_constant}

\paragraph{rule\_expression()}

In this rule \code{tokens} already contains BDDs, since the rules \code{rule\_variable} or \code{rule\_constant} have been executed (for the subformula) before. There are now a few basic possibilities:

\begin{enumerate}
    \item \code{tokens} contains a single BDD returned by the function \code{rule\_constant} or \code{rule\_variable}. In this case we just return the given BDD.
    \item \code{tokens} contains a single BDD and two parenthesis. We just return the BDD.
    \item \code{tokens} contains a not sign ($¬$) followed by an BDD. We invert the tree by swapping the 0- and 1-terminals. After that we return the new BDD.
    \item \code{tokens} contains one BDD, followed by a binary operator and another BDD. In this case we use the function \code{apply} from the lecture slides to create a new BDD.
\end{enumerate}

\codeinput{rule_expression}

\paragraph{rule\_formula()}

This rule already gets the final BDD from the last application of \code{rule\_expression()}. The only thing left to do is to return this BDD.

\codeinput{rule_formula}

\newpage
\section{Temporal Logic}

\subsection{Exercise 5}

Prove the equivalence for $A(f U g)$ on page 16.

\subsubsection{Solution}

\input{TeX/equivalence_AU_solution}

\subsection{Exercise 6}

Show the following lemma: Let $M$ and $N$ be two Kripke structures such that the transition relation of $M$ is a superset of the transition relation of $N$. If an LTL property $f$ holds on $M$, then $f$ also holds on $N$.

\subsubsection{Solution}

\input{TeX/ltl_formula_holds_subset_kripke_structure_solution}

\subsection{Exercise 7}

Show AFG p is not logically equivalent to AFAG. Which of the two formulas implies the other one?

\subsection{Exercise 8}

Show that all LTL properties have counterexamples which are either finite paths or finite paths which lead to a loop.

\subsection{Exercise 9}

Give an LTL specification and a Kripke structure where the smallest counterexample is larger than the number of states in the Kripke structure.

\subsection{Exercise 10}

Show how you can use SMV to solve the Rubik’s cube.

\section{Questions to Test Your Understanding}

Are the following statements correct/false? Why?

\begin{enumerate}[label=(\alph*)]
    \item CTL is contained in LTL
    \item LTL is contained in CTL*
    \item Every CTL formula is equivalent to a formula containing only E, but no A
    \item Every LTL formula is equivalent to a negation-free formula containing only A, but no E
    \item For each Boolean function f over n variables, there exists an order on the variables such that the BDD for f has size linear in n.
    \item Every BDD can be translated into an equivalent Boolean formula.
    \item On a Kripke structure M, the size of a counterexample is bounded by the number of states in M, multiplied by the size of the specification.
    \item Bounded model checking can be used to find the smallest counterexample.
    \item In SMV, each BDD node corresponds to a state in the Kripke structure.
    \item In SMV, BDDs are used as specification language.
\end{enumerate}

\end{document}
